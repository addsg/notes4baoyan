### 邻接表存图
```
void add(int a, int b, int c)
{
    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;
    // h[] 存链表头 e[]存所有节点的值 ne[]存next指针  w[]存边权
}
// 遍历
for(int i = h[t]; ~i; i = ne[i])
{

}

```

### bellman-ford 算法  

&ensp; 复杂度 $O(|V||E|)$

&ensp; for $1 : n $(最多经过n条边) 

&ensp; &ensp; 遍历每条边 $a,b,w$

&ensp; &ensp; $dist[b]$ = $min(dist[b] , back[a] + w)$ 

&ensp; 注意$back[]$数组是上一次迭代后$dist[]$ 数组的备份，由于是每个点同时向外出发，因此需要对数组进行备份，若不进行备份会因此发生串联效应，影响到下一个点>



### spfa算法(bellman-ford的改进)  
&ensp; 在bellman-ford中，会盲目迭代每一条边，spfa的思想是只有当$dist[a]$被更新后,$dist[b]$才有可能被更新，故采用一个队列来记录被更新过的节点 
&ensp; 复杂度：一般$O(m)$,最坏$O(mn)$   $n$为点的数目， $m$为边的数目

### dijkstra算法
复杂度： 朴素版$O(n^2)$ 堆优化 $O(mlogn)$ 
具体实现: 设置初始源点，维护一个集合$S$,然后进行$n$次迭代，每次选一个最短路长度最小的点并将其 
加入集合，同时对其他边进行松弛（更新）操作